{"ast":null,"code":"import { Document } from \"./document.js\";\nimport { getEncoding } from \"./util/tiktoken.js\";\nimport { BaseDocumentTransformer } from \"./schema/document.js\";\nexport class TextSplitter extends BaseDocumentTransformer {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n    });\n    Object.defineProperty(this, \"chunkSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1000\n    });\n    Object.defineProperty(this, \"chunkOverlap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 200\n    });\n    Object.defineProperty(this, \"keepSeparator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lengthFunction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n    this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n    this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n    this.lengthFunction = fields?.lengthFunction ?? (text => text.length);\n    if (this.chunkOverlap >= this.chunkSize) {\n      throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n    }\n  }\n  async transformDocuments(documents, chunkHeaderOptions = {}) {\n    return this.splitDocuments(documents, chunkHeaderOptions);\n  }\n  splitOnSeparator(text, separator) {\n    let splits;\n    if (separator) {\n      if (this.keepSeparator) {\n        const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n      } else {\n        splits = text.split(separator);\n      }\n    } else {\n      splits = text.split(\"\");\n    }\n    return splits.filter(s => s !== \"\");\n  }\n  async createDocuments(texts,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadatas = [], chunkHeaderOptions = {}) {\n    // if no metadata is provided, we create an empty one for each text\n    const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n    const {\n      chunkHeader = \"\",\n      chunkOverlapHeader = \"(cont'd) \",\n      appendChunkOverlapHeader = false\n    } = chunkHeaderOptions;\n    const documents = new Array();\n    for (let i = 0; i < texts.length; i += 1) {\n      const text = texts[i];\n      let lineCounterIndex = 1;\n      let prevChunk = null;\n      for (const chunk of await this.splitText(text)) {\n        let pageContent = chunkHeader;\n        // we need to count the \\n that are in the text before getting removed by the splitting\n        let numberOfIntermediateNewLines = 0;\n        if (prevChunk) {\n          const indexChunk = text.indexOf(chunk);\n          const indexEndPrevChunk = text.indexOf(prevChunk) + (await this.lengthFunction(prevChunk));\n          const removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk);\n          numberOfIntermediateNewLines = (removedNewlinesFromSplittingText.match(/\\n/g) || []).length;\n          if (appendChunkOverlapHeader) {\n            pageContent += chunkOverlapHeader;\n          }\n        }\n        lineCounterIndex += numberOfIntermediateNewLines;\n        const newLinesCount = (chunk.match(/\\n/g) || []).length;\n        const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\" ? {\n          ..._metadatas[i].loc\n        } : {};\n        loc.lines = {\n          from: lineCounterIndex,\n          to: lineCounterIndex + newLinesCount\n        };\n        const metadataWithLinesNumber = {\n          ..._metadatas[i],\n          loc\n        };\n        pageContent += chunk;\n        documents.push(new Document({\n          pageContent,\n          metadata: metadataWithLinesNumber\n        }));\n        lineCounterIndex += newLinesCount;\n        prevChunk = chunk;\n      }\n    }\n    return documents;\n  }\n  async splitDocuments(documents, chunkHeaderOptions = {}) {\n    const selectedDocuments = documents.filter(doc => doc.pageContent !== undefined);\n    const texts = selectedDocuments.map(doc => doc.pageContent);\n    const metadatas = selectedDocuments.map(doc => doc.metadata);\n    return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n  }\n  joinDocs(docs, separator) {\n    const text = docs.join(separator).trim();\n    return text === \"\" ? null : text;\n  }\n  async mergeSplits(splits, separator) {\n    const docs = [];\n    const currentDoc = [];\n    let total = 0;\n    for (const d of splits) {\n      const _len = await this.lengthFunction(d);\n      if (total + _len + (currentDoc.length > 0 ? separator.length : 0) > this.chunkSize) {\n        if (total > this.chunkSize) {\n          console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n        }\n        if (currentDoc.length > 0) {\n          const doc = this.joinDocs(currentDoc, separator);\n          if (doc !== null) {\n            docs.push(doc);\n          }\n          // Keep on popping if:\n          // - we have a larger chunk than in the chunk overlap\n          // - or if we still have any chunks and the length is long\n          while (total > this.chunkOverlap || total + _len > this.chunkSize && total > 0) {\n            total -= await this.lengthFunction(currentDoc[0]);\n            currentDoc.shift();\n          }\n        }\n      }\n      currentDoc.push(d);\n      total += _len;\n    }\n    const doc = this.joinDocs(currentDoc, separator);\n    if (doc !== null) {\n      docs.push(doc);\n    }\n    return docs;\n  }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"CharacterTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\\n\\n\"\n    });\n    this.separator = fields?.separator ?? this.separator;\n  }\n  async splitText(text) {\n    // First we naively split the large input into a bunch of smaller ones.\n    const splits = this.splitOnSeparator(text, this.separator);\n    return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n  }\n}\nexport const SupportedTextSplitterLanguages = [\"cpp\", \"go\", \"java\", \"js\", \"php\", \"proto\", \"python\", \"rst\", \"ruby\", \"rust\", \"scala\", \"swift\", \"markdown\", \"latex\", \"html\", \"sol\"];\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"RecursiveCharacterTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separators\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n    });\n    this.separators = fields?.separators ?? this.separators;\n    this.keepSeparator = fields?.keepSeparator ?? true;\n  }\n  async _splitText(text, separators) {\n    const finalChunks = [];\n    // Get appropriate separator to use\n    let separator = separators[separators.length - 1];\n    let newSeparators;\n    for (let i = 0; i < separators.length; i += 1) {\n      const s = separators[i];\n      if (s === \"\") {\n        separator = s;\n        break;\n      }\n      if (text.includes(s)) {\n        separator = s;\n        newSeparators = separators.slice(i + 1);\n        break;\n      }\n    }\n    // Now that we have the separator, split the text\n    const splits = this.splitOnSeparator(text, separator);\n    // Now go merging things, recursively splitting longer texts.\n    let goodSplits = [];\n    const _separator = this.keepSeparator ? \"\" : separator;\n    for (const s of splits) {\n      if ((await this.lengthFunction(s)) < this.chunkSize) {\n        goodSplits.push(s);\n      } else {\n        if (goodSplits.length) {\n          const mergedText = await this.mergeSplits(goodSplits, _separator);\n          finalChunks.push(...mergedText);\n          goodSplits = [];\n        }\n        if (!newSeparators) {\n          finalChunks.push(s);\n        } else {\n          const otherInfo = await this._splitText(s, newSeparators);\n          finalChunks.push(...otherInfo);\n        }\n      }\n    }\n    if (goodSplits.length) {\n      const mergedText = await this.mergeSplits(goodSplits, _separator);\n      finalChunks.push(...mergedText);\n    }\n    return finalChunks;\n  }\n  async splitText(text) {\n    return this._splitText(text, this.separators);\n  }\n  static fromLanguage(language, options) {\n    return new RecursiveCharacterTextSplitter({\n      ...options,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language)\n    });\n  }\n  static getSeparatorsForLanguage(language) {\n    if (language === \"cpp\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along function definitions\n      \"\\nvoid \", \"\\nint \", \"\\nfloat \", \"\\ndouble \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"go\") {\n      return [\n      // Split along function definitions\n      \"\\nfunc \", \"\\nvar \", \"\\nconst \", \"\\ntype \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"java\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along method definitions\n      \"\\npublic \", \"\\nprotected \", \"\\nprivate \", \"\\nstatic \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"js\") {\n      return [\n      // Split along function definitions\n      \"\\nfunction \", \"\\nconst \", \"\\nlet \", \"\\nvar \", \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \", \"\\ndefault \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"php\") {\n      return [\n      // Split along function definitions\n      \"\\nfunction \",\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nforeach \", \"\\nwhile \", \"\\ndo \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"proto\") {\n      return [\n      // Split along message definitions\n      \"\\nmessage \",\n      // Split along service definitions\n      \"\\nservice \",\n      // Split along enum definitions\n      \"\\nenum \",\n      // Split along option definitions\n      \"\\noption \",\n      // Split along import statements\n      \"\\nimport \",\n      // Split along syntax declarations\n      \"\\nsyntax \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"python\") {\n      return [\n      // First, try to split along class definitions\n      \"\\nclass \", \"\\ndef \", \"\\n\\tdef \",\n      // Now split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"rst\") {\n      return [\n      // Split along section titles\n      \"\\n===\\n\", \"\\n---\\n\", \"\\n***\\n\",\n      // Split along directive markers\n      \"\\n.. \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"ruby\") {\n      return [\n      // Split along method definitions\n      \"\\ndef \", \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nunless \", \"\\nwhile \", \"\\nfor \", \"\\ndo \", \"\\nbegin \", \"\\nrescue \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"rust\") {\n      return [\n      // Split along function definitions\n      \"\\nfn \", \"\\nconst \", \"\\nlet \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nwhile \", \"\\nfor \", \"\\nloop \", \"\\nmatch \", \"\\nconst \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"scala\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \", \"\\nobject \",\n      // Split along method definitions\n      \"\\ndef \", \"\\nval \", \"\\nvar \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nmatch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"swift\") {\n      return [\n      // Split along function definitions\n      \"\\nfunc \",\n      // Split along class definitions\n      \"\\nclass \", \"\\nstruct \", \"\\nenum \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\ndo \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"markdown\") {\n      return [\n      // First, try to split along Markdown headings (starting with level 2)\n      \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \", \"\\n###### \",\n      // Note the alternative syntax for headings (below) is not handled here\n      // Heading level 2\n      // ---------------\n      // End of code block\n      \"```\\n\\n\",\n      // Horizontal lines\n      \"\\n\\n***\\n\\n\", \"\\n\\n---\\n\\n\", \"\\n\\n___\\n\\n\",\n      // Note that this splitter doesn't handle horizontal lines defined\n      // by *three or more* of ***, ---, or ___, but this is not handled\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"latex\") {\n      return [\n      // First, try to split along Latex sections\n      \"\\n\\\\chapter{\", \"\\n\\\\section{\", \"\\n\\\\subsection{\", \"\\n\\\\subsubsection{\",\n      // Now split by environments\n      \"\\n\\\\begin{enumerate}\", \"\\n\\\\begin{itemize}\", \"\\n\\\\begin{description}\", \"\\n\\\\begin{list}\", \"\\n\\\\begin{quote}\", \"\\n\\\\begin{quotation}\", \"\\n\\\\begin{verse}\", \"\\n\\\\begin{verbatim}\",\n      // Now split by math environments\n      \"\\n\\\\begin{align}\", \"$$\", \"$\",\n      // Now split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"html\") {\n      return [\n      // First, try to split along HTML tags\n      \"<body>\", \"<div>\", \"<p>\", \"<br>\", \"<li>\", \"<h1>\", \"<h2>\", \"<h3>\", \"<h4>\", \"<h5>\", \"<h6>\", \"<span>\", \"<table>\", \"<tr>\", \"<td>\", \"<th>\", \"<ul>\", \"<ol>\", \"<header>\", \"<footer>\", \"<nav>\",\n      // Head\n      \"<head>\", \"<style>\", \"<script>\", \"<meta>\", \"<title>\",\n      // Normal type of lines\n      \" \", \"\"];\n    } else if (language === \"sol\") {\n      return [\n      // Split along compiler informations definitions\n      \"\\npragma \", \"\\nusing \",\n      // Split along contract definitions\n      \"\\ncontract \", \"\\ninterface \", \"\\nlibrary \",\n      // Split along method definitions\n      \"\\nconstructor \", \"\\ntype \", \"\\nfunction \", \"\\nevent \", \"\\nmodifier \", \"\\nerror \", \"\\nstruct \", \"\\nenum \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\ndo while \", \"\\nassembly \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else {\n      throw new Error(`Language ${language} is not supported.`);\n    }\n  }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"TokenTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"encodingName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"allowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"disallowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tokenizer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.encodingName = fields?.encodingName ?? \"gpt2\";\n    this.allowedSpecial = fields?.allowedSpecial ?? [];\n    this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n  }\n  async splitText(text) {\n    if (!this.tokenizer) {\n      this.tokenizer = await getEncoding(this.encodingName);\n    }\n    const splits = [];\n    const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n    let start_idx = 0;\n    let cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n    let chunk_ids = input_ids.slice(start_idx, cur_idx);\n    while (start_idx < input_ids.length) {\n      splits.push(this.tokenizer.decode(chunk_ids));\n      start_idx += this.chunkSize - this.chunkOverlap;\n      cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n      chunk_ids = input_ids.slice(start_idx, cur_idx);\n    }\n    return splits;\n  }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n  constructor(fields) {\n    super({\n      ...fields,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\")\n    });\n  }\n}\nexport class LatexTextSplitter extends RecursiveCharacterTextSplitter {\n  constructor(fields) {\n    super({\n      ...fields,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\")\n    });\n  }\n}","map":{"version":3,"names":["Document","getEncoding","BaseDocumentTransformer","TextSplitter","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","chunkSize","chunkOverlap","keepSeparator","lengthFunction","text","length","Error","transformDocuments","documents","chunkHeaderOptions","splitDocuments","splitOnSeparator","separator","splits","regexEscapedSeparator","replace","split","RegExp","filter","s","createDocuments","texts","metadatas","_metadatas","Array","fill","chunkHeader","chunkOverlapHeader","appendChunkOverlapHeader","i","lineCounterIndex","prevChunk","chunk","splitText","pageContent","numberOfIntermediateNewLines","indexChunk","indexOf","indexEndPrevChunk","removedNewlinesFromSplittingText","slice","match","newLinesCount","loc","lines","from","to","metadataWithLinesNumber","push","metadata","selectedDocuments","doc","undefined","map","joinDocs","docs","join","trim","mergeSplits","currentDoc","total","d","_len","console","warn","shift","CharacterTextSplitter","lc_name","SupportedTextSplitterLanguages","RecursiveCharacterTextSplitter","separators","_splitText","finalChunks","newSeparators","includes","goodSplits","_separator","mergedText","otherInfo","fromLanguage","language","options","getSeparatorsForLanguage","TokenTextSplitter","encodingName","allowedSpecial","disallowedSpecial","tokenizer","input_ids","encode","start_idx","cur_idx","Math","min","chunk_ids","decode","MarkdownTextSplitter","LatexTextSplitter"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/text_splitter.js"],"sourcesContent":["import { Document } from \"./document.js\";\nimport { getEncoding } from \"./util/tiktoken.js\";\nimport { BaseDocumentTransformer } from \"./schema/document.js\";\nexport class TextSplitter extends BaseDocumentTransformer {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n        });\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        Object.defineProperty(this, \"keepSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lengthFunction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n        this.lengthFunction =\n            fields?.lengthFunction ?? ((text) => text.length);\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async transformDocuments(documents, chunkHeaderOptions = {}) {\n        return this.splitDocuments(documents, chunkHeaderOptions);\n    }\n    splitOnSeparator(text, separator) {\n        let splits;\n        if (separator) {\n            if (this.keepSeparator) {\n                const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n            }\n            else {\n                splits = text.split(separator);\n            }\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        return splits.filter((s) => s !== \"\");\n    }\n    async createDocuments(texts, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = [], chunkHeaderOptions = {}) {\n        // if no metadata is provided, we create an empty one for each text\n        const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n        const { chunkHeader = \"\", chunkOverlapHeader = \"(cont'd) \", appendChunkOverlapHeader = false, } = chunkHeaderOptions;\n        const documents = new Array();\n        for (let i = 0; i < texts.length; i += 1) {\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            for (const chunk of await this.splitText(text)) {\n                let pageContent = chunkHeader;\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                let numberOfIntermediateNewLines = 0;\n                if (prevChunk) {\n                    const indexChunk = text.indexOf(chunk);\n                    const indexEndPrevChunk = text.indexOf(prevChunk) + (await this.lengthFunction(prevChunk));\n                    const removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk);\n                    numberOfIntermediateNewLines = (removedNewlinesFromSplittingText.match(/\\n/g) || []).length;\n                    if (appendChunkOverlapHeader) {\n                        pageContent += chunkOverlapHeader;\n                    }\n                }\n                lineCounterIndex += numberOfIntermediateNewLines;\n                const newLinesCount = (chunk.match(/\\n/g) || []).length;\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\"\n                    ? { ..._metadatas[i].loc }\n                    : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount,\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc,\n                };\n                pageContent += chunk;\n                documents.push(new Document({\n                    pageContent,\n                    metadata: metadataWithLinesNumber,\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n            }\n        }\n        return documents;\n    }\n    async splitDocuments(documents, chunkHeaderOptions = {}) {\n        const selectedDocuments = documents.filter((doc) => doc.pageContent !== undefined);\n        const texts = selectedDocuments.map((doc) => doc.pageContent);\n        const metadatas = selectedDocuments.map((doc) => doc.metadata);\n        return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    async mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits) {\n            const _len = await this.lengthFunction(d);\n            if (total + _len + (currentDoc.length > 0 ? separator.length : 0) >\n                this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while (total > this.chunkOverlap ||\n                        (total + _len > this.chunkSize && total > 0)) {\n                        total -= await this.lengthFunction(currentDoc[0]);\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"CharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        const splits = this.splitOnSeparator(text, this.separator);\n        return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n    }\n}\nexport const SupportedTextSplitterLanguages = [\n    \"cpp\",\n    \"go\",\n    \"java\",\n    \"js\",\n    \"php\",\n    \"proto\",\n    \"python\",\n    \"rst\",\n    \"ruby\",\n    \"rust\",\n    \"scala\",\n    \"swift\",\n    \"markdown\",\n    \"latex\",\n    \"html\",\n    \"sol\",\n];\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"RecursiveCharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n        });\n        this.separators = fields?.separators ?? this.separators;\n        this.keepSeparator = fields?.keepSeparator ?? true;\n    }\n    async _splitText(text, separators) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = separators[separators.length - 1];\n        let newSeparators;\n        for (let i = 0; i < separators.length; i += 1) {\n            const s = separators[i];\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                newSeparators = separators.slice(i + 1);\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        const splits = this.splitOnSeparator(text, separator);\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        const _separator = this.keepSeparator ? \"\" : separator;\n        for (const s of splits) {\n            if ((await this.lengthFunction(s)) < this.chunkSize) {\n                goodSplits.push(s);\n            }\n            else {\n                if (goodSplits.length) {\n                    const mergedText = await this.mergeSplits(goodSplits, _separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                if (!newSeparators) {\n                    finalChunks.push(s);\n                }\n                else {\n                    const otherInfo = await this._splitText(s, newSeparators);\n                    finalChunks.push(...otherInfo);\n                }\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = await this.mergeSplits(goodSplits, _separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n    async splitText(text) {\n        return this._splitText(text, this.separators);\n    }\n    static fromLanguage(language, options) {\n        return new RecursiveCharacterTextSplitter({\n            ...options,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language),\n        });\n    }\n    static getSeparatorsForLanguage(language) {\n        if (language === \"cpp\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along function definitions\n                \"\\nvoid \",\n                \"\\nint \",\n                \"\\nfloat \",\n                \"\\ndouble \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"go\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                \"\\nvar \",\n                \"\\nconst \",\n                \"\\ntype \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"java\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along method definitions\n                \"\\npublic \",\n                \"\\nprotected \",\n                \"\\nprivate \",\n                \"\\nstatic \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"js\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                \"\\nconst \",\n                \"\\nlet \",\n                \"\\nvar \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                \"\\ndefault \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"php\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nforeach \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"proto\") {\n            return [\n                // Split along message definitions\n                \"\\nmessage \",\n                // Split along service definitions\n                \"\\nservice \",\n                // Split along enum definitions\n                \"\\nenum \",\n                // Split along option definitions\n                \"\\noption \",\n                // Split along import statements\n                \"\\nimport \",\n                // Split along syntax declarations\n                \"\\nsyntax \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"python\") {\n            return [\n                // First, try to split along class definitions\n                \"\\nclass \",\n                \"\\ndef \",\n                \"\\n\\tdef \",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rst\") {\n            return [\n                // Split along section titles\n                \"\\n===\\n\",\n                \"\\n---\\n\",\n                \"\\n***\\n\",\n                // Split along directive markers\n                \"\\n.. \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"ruby\") {\n            return [\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nunless \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\ndo \",\n                \"\\nbegin \",\n                \"\\nrescue \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rust\") {\n            return [\n                // Split along function definitions\n                \"\\nfn \",\n                \"\\nconst \",\n                \"\\nlet \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\nloop \",\n                \"\\nmatch \",\n                \"\\nconst \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"scala\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nobject \",\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nval \",\n                \"\\nvar \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nmatch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"swift\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"sol\") {\n            return [\n                // Split along compiler informations definitions\n                \"\\npragma \",\n                \"\\nusing \",\n                // Split along contract definitions\n                \"\\ncontract \",\n                \"\\ninterface \",\n                \"\\nlibrary \",\n                // Split along method definitions\n                \"\\nconstructor \",\n                \"\\ntype \",\n                \"\\nfunction \",\n                \"\\nevent \",\n                \"\\nmodifier \",\n                \"\\nerror \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo while \",\n                \"\\nassembly \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else {\n            throw new Error(`Language ${language} is not supported.`);\n        }\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"TokenTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            this.tokenizer = await getEncoding(this.encodingName);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        let cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n        let chunk_ids = input_ids.slice(start_idx, cur_idx);\n        while (start_idx < input_ids.length) {\n            splits.push(this.tokenizer.decode(chunk_ids));\n            start_idx += this.chunkSize - this.chunkOverlap;\n            cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            chunk_ids = input_ids.slice(start_idx, cur_idx);\n        }\n        return splits;\n    }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\"),\n        });\n    }\n}\nexport class LatexTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\"),\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}