{"ast":null,"code":"/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nexport class BaseMemory {}\nconst getValue = (values, key) => {\n  if (key !== undefined) {\n    return values[key];\n  }\n  const keys = Object.keys(values);\n  if (keys.length === 1) {\n    return values[keys[0]];\n  }\n};\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues, inputKey) => {\n  const value = getValue(inputValues, inputKey);\n  if (!value) {\n    const keys = Object.keys(inputValues);\n    throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);\n  }\n  return value;\n};\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (outputValues, outputKey) => {\n  const value = getValue(outputValues, outputKey);\n  if (!value) {\n    const keys = Object.keys(outputValues);\n    throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);\n  }\n  return value;\n};\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    string_messages.push(`${role}: ${nameStr}${m.content}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nexport function getPromptInputKey(inputs, memoryVariables) {\n  const promptInputKeys = Object.keys(inputs).filter(key => !memoryVariables.includes(key) && key !== \"stop\");\n  if (promptInputKeys.length !== 1) {\n    throw new Error(`One input key expected, but got ${promptInputKeys.length}`);\n  }\n  return promptInputKeys[0];\n}","map":{"version":3,"names":["BaseMemory","getValue","values","key","undefined","keys","Object","length","getInputValue","inputValues","inputKey","value","Error","getOutputValue","outputValues","outputKey","getBufferString","messages","humanPrefix","aiPrefix","string_messages","m","role","_getType","nameStr","name","push","content","join","getPromptInputKey","inputs","memoryVariables","promptInputKeys","filter","includes"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/memory/base.js"],"sourcesContent":["/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nexport class BaseMemory {\n}\nconst getValue = (values, key) => {\n    if (key !== undefined) {\n        return values[key];\n    }\n    const keys = Object.keys(values);\n    if (keys.length === 1) {\n        return values[keys[0]];\n    }\n};\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues, inputKey) => {\n    const value = getValue(inputValues, inputKey);\n    if (!value) {\n        const keys = Object.keys(inputValues);\n        throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);\n    }\n    return value;\n};\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (outputValues, outputKey) => {\n    const value = getValue(outputValues, outputKey);\n    if (!value) {\n        const keys = Object.keys(outputValues);\n        throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);\n    }\n    return value;\n};\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nexport function getPromptInputKey(inputs, memoryVariables) {\n    const promptInputKeys = Object.keys(inputs).filter((key) => !memoryVariables.includes(key) && key !== \"stop\");\n    if (promptInputKeys.length !== 1) {\n        throw new Error(`One input key expected, but got ${promptInputKeys.length}`);\n    }\n    return promptInputKeys[0];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}