{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable, getRuntimeEnvironment } from \"./utils/env.js\";\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.validateApiKeyIfHosted();\n    this.timeout_ms = config.timeout_ms ?? 4000;\n    this.caller = new AsyncCaller(config.callerOptions ?? {});\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? (apiKey ? \"https://api.smith.langchain.com\" : \"http://localhost:1984\");\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey\n    };\n  }\n  validateApiKeyIfHosted() {\n    const isLocal = isLocalhost(this.apiUrl);\n    if (!isLocal && !this.apiKey) {\n      throw new Error(\"API key must be provided when using hosted LangSmith API\");\n    }\n  }\n  getHostUrl() {\n    if (isLocalhost(this.apiUrl)) {\n      return \"http://localhost\";\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {};\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  async _get(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams()) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(fetch, url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n      }\n      const items = await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async createRun(run) {\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const extra = run.extra ?? {};\n    const runtimeEnv = await getRuntimeEnvironment();\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = {\n      session_name,\n      ...run,\n      extra: {\n        ...run.extra,\n        runtime: {\n          ...runtimeEnv,\n          ...extra.runtime\n        }\n      }\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(runCreate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  async updateRun(runId, run) {\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId\n  }) {\n    const run = await this.readRun(runId);\n    if (!run.app_path) {\n      return undefined;\n    }\n    const baseUrl = this.getHostUrl();\n    return `${baseUrl}${run.app_path}`;\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    childRuns.sort((a, b) => a.execution_order - b.execution_order);\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  async *listRuns({\n    projectId,\n    projectName,\n    parentRunId,\n    referenceExampleId,\n    startTime,\n    executionOrder,\n    runType,\n    error,\n    id,\n    limit,\n    offset,\n    query,\n    filter\n  }) {\n    const queryParams = new URLSearchParams();\n    let projectId_ = projectId;\n    if (projectName) {\n      if (projectId) {\n        throw new Error(\"Only one of projectId or projectName may be given\");\n      }\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    }\n    if (projectId_) {\n      queryParams.append(\"session\", projectId_);\n    }\n    if (parentRunId) {\n      queryParams.append(\"parent_run\", parentRunId);\n    }\n    if (referenceExampleId) {\n      queryParams.append(\"reference_example\", referenceExampleId);\n    }\n    if (startTime) {\n      queryParams.append(\"start_time\", startTime.toISOString());\n    }\n    if (executionOrder) {\n      queryParams.append(\"execution_order\", executionOrder.toString());\n    }\n    if (runType) {\n      queryParams.append(\"run_type\", runType);\n    }\n    if (error !== undefined) {\n      queryParams.append(\"error\", error.toString());\n    }\n    if (id !== undefined) {\n      for (const id_ of id) {\n        queryParams.append(\"id\", id_);\n      }\n    }\n    if (limit !== undefined) {\n      queryParams.append(\"limit\", limit.toString());\n    }\n    if (offset !== undefined) {\n      queryParams.append(\"offset\", offset.toString());\n    }\n    if (query !== undefined) {\n      queryParams.append(\"query\", query);\n    }\n    if (filter !== undefined) {\n      queryParams.append(\"filter\", filter);\n    }\n    for await (const runs of this._getPaginated(\"/runs\", queryParams)) {\n      yield* runs;\n    }\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async createProject({\n    projectName,\n    projectExtra,\n    upsert\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const body = {\n      name: projectName\n    };\n    if (projectExtra !== undefined) {\n      body[\"extra\"] = projectExtra;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async readProject({\n    projectId,\n    projectName\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${fileName} already exists`);\n      }\n      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType\n  } = {}) {\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${name} already exists`);\n      }\n      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      path += `/${datasetId}`;\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, {\n    datasetId,\n    datasetName,\n    createdAt\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_.toISOString()\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readExample(exampleId) {\n    const path = `/examples/${exampleId}`;\n    return await this._get(path);\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    for await (const examples of this._getPaginated(\"/examples\", params)) {\n      yield* examples;\n    }\n  }\n  async deleteExample(exampleId) {\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    let referenceExample = undefined;\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo ?? {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    return await this.createFeedback(run_.id, feedbackResult.key, {\n      score: feedbackResult.score,\n      value: feedbackResult.value,\n      comment: feedbackResult.comment,\n      correction: feedbackResult.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"MODEL\"\n    });\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"API\",\n    sourceRunId\n  }) {\n    let feedback_source;\n    if (feedbackSourceType === \"API\") {\n      feedback_source = {\n        type: \"api\",\n        metadata: sourceInfo ?? {}\n      };\n    } else if (feedbackSourceType === \"MODEL\") {\n      feedback_source = {\n        type: \"model\",\n        metadata: sourceInfo ?? {}\n      };\n    } else {\n      throw new Error(`Unknown feedback source type ${feedbackSourceType}`);\n    }\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    const feedback = {\n      id: uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create feedback for run ${runId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    return response.json();\n  }\n  async readFeedback(feedbackId) {\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async *listFeedback({\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","getEnvironmentVariable","getRuntimeEnvironment","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","Error","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","undefined","trim","Client","constructor","config","Object","defineProperty","enumerable","configurable","writable","value","defaultConfig","getDefaultClientConfig","apiUrl","apiKey","validateApiKeyIfHosted","timeout_ms","caller","callerOptions","isLocal","getHostUrl","includes","headers","_get","path","queryParams","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","json","_getPaginated","URLSearchParams","offset","Number","get","limit","set","String","items","length","createRun","run","extra","runtimeEnv","session_name","project_name","runCreate","runtime","JSON","stringify","updateRun","runId","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","app_path","baseUrl","childRuns","listRuns","id","treemap","runs","sort","a","b","execution_order","childRun","parent_run_id","child_runs","projectId","projectName","parentRunId","referenceExampleId","startTime","executionOrder","runType","error","query","filter","projectId_","readProject","append","toISOString","id_","shareRun","shareId","data","run_id","share_token","v4","unshareRun","readRunSharedLink","createProject","projectExtra","upsert","upsert_","endpoint","name","params","Array","isArray","listProjects","projectIds","nameContains","referenceDatasetId","referenceDatasetName","referenceFree","dataset","readDataset","datasetName","projects","deleteProject","uploadCsv","csvFile","fileName","inputKeys","outputKeys","description","dataType","formData","FormData","forEach","key","detail","createDataset","data_type","datasetId","listDatasets","datasetIds","datasetNameContains","datasets","deleteDataset","datasetId_","createExample","inputs","outputs","createdAt","createdAt_","Date","dataset_id","created_at","readExample","exampleId","listExamples","exampleIds","examples","deleteExample","updateExample","update","evaluateRun","evaluator","sourceInfo","run_","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","feedback_source","type","metadata","feedback","updateFeedback","feedbackId","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","runIds","join","feedbacks"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable, getRuntimeEnvironment } from \"./utils/env.js\";\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 4000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            (apiKey ? \"https://api.smith.langchain.com\" : \"http://localhost:1984\");\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (isLocalhost(this.apiUrl)) {\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {};\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    async _get(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async createRun(run) {\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const extra = run.extra ?? {};\n        const runtimeEnv = await getRuntimeEnvironment();\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = {\n            session_name,\n            ...run,\n            extra: {\n                ...run.extra,\n                runtime: {\n                    ...runtimeEnv,\n                    ...extra.runtime,\n                },\n            },\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(runCreate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    async updateRun(runId, run) {\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, }) {\n        const run = await this.readRun(runId);\n        if (!run.app_path) {\n            return undefined;\n        }\n        const baseUrl = this.getHostUrl();\n        return `${baseUrl}${run.app_path}`;\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        childRuns.sort((a, b) => a.execution_order - b.execution_order);\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, referenceExampleId, startTime, executionOrder, runType, error, id, limit, offset, query, filter, }) {\n        const queryParams = new URLSearchParams();\n        let projectId_ = projectId;\n        if (projectName) {\n            if (projectId) {\n                throw new Error(\"Only one of projectId or projectName may be given\");\n            }\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        if (projectId_) {\n            queryParams.append(\"session\", projectId_);\n        }\n        if (parentRunId) {\n            queryParams.append(\"parent_run\", parentRunId);\n        }\n        if (referenceExampleId) {\n            queryParams.append(\"reference_example\", referenceExampleId);\n        }\n        if (startTime) {\n            queryParams.append(\"start_time\", startTime.toISOString());\n        }\n        if (executionOrder) {\n            queryParams.append(\"execution_order\", executionOrder.toString());\n        }\n        if (runType) {\n            queryParams.append(\"run_type\", runType);\n        }\n        if (error !== undefined) {\n            queryParams.append(\"error\", error.toString());\n        }\n        if (id !== undefined) {\n            for (const id_ of id) {\n                queryParams.append(\"id\", id_);\n            }\n        }\n        if (limit !== undefined) {\n            queryParams.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            queryParams.append(\"offset\", offset.toString());\n        }\n        if (query !== undefined) {\n            queryParams.append(\"query\", query);\n        }\n        if (filter !== undefined) {\n            queryParams.append(\"filter\", filter);\n        }\n        for await (const runs of this._getPaginated(\"/runs\", queryParams)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async createProject({ projectName, projectExtra, upsert, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const body = {\n            name: projectName,\n        };\n        if (projectExtra !== undefined) {\n            body[\"extra\"] = projectExtra;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async readProject({ projectId, projectName, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_.toISOString(),\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readExample(exampleId) {\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        let referenceExample = undefined;\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        return await this.createFeedback(run_.id, feedbackResult.key, {\n            score: feedbackResult.score,\n            value: feedbackResult.value,\n            comment: feedbackResult.comment,\n            correction: feedbackResult.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"MODEL\",\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"API\", sourceRunId, }) {\n        let feedback_source;\n        if (feedbackSourceType === \"API\") {\n            feedback_source = { type: \"api\", metadata: sourceInfo ?? {} };\n        }\n        else if (feedbackSourceType === \"MODEL\") {\n            feedback_source = { type: \"model\", metadata: sourceInfo ?? {} };\n        }\n        else {\n            throw new Error(`Unknown feedback source type ${feedbackSourceType}`);\n        }\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        const feedback = {\n            id: uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create feedback for run ${runId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        return response.json();\n    }\n    async readFeedback(feedbackId) {\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}