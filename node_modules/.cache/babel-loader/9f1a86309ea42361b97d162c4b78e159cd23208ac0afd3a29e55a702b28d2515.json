{"ast":null,"code":"import { Runnable } from \"./runnable.js\";\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport class BaseLLMOutputParser extends Runnable {\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(generations, _prompt, callbacks) {\n    return this.parseResult(generations, callbacks);\n  }\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(input, options) {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(async input => this.parseResult([{\n        text: input\n      }]), input, {\n        ...options,\n        runType: \"parser\"\n      });\n    } else {\n      return this._callWithConfig(async input => this.parseResult([{\n        message: input,\n        text: input.content\n      }]), input, {\n        ...options,\n        runType: \"parser\"\n      });\n    }\n  }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nexport class BaseOutputParser extends BaseLLMOutputParser {\n  parseResult(generations, callbacks) {\n    return this.parse(generations[0].text, callbacks);\n  }\n  async parseWithPrompt(text, _prompt, callbacks) {\n    return this.parse(text, callbacks);\n  }\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type() {\n    throw new Error(\"_type not implemented\");\n  }\n}\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n  async *_transform(inputGenerator) {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{\n          text: chunk\n        }]);\n      } else {\n        yield this.parseResult([{\n          message: chunk,\n          text: chunk.content\n        }]);\n      }\n    }\n  }\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(inputGenerator, options) {\n    yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n      ...options,\n      runType: \"parser\"\n    });\n  }\n}\n/**\n * OutputParser that parses LLMResult into the top likely string.\n */\nexport class StringOutputParser extends BaseTransformOutputParser {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"output_parser\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text) {\n    return Promise.resolve(text);\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"output_parser\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"textEncoder\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new TextEncoder()\n    });\n  }\n  static lc_name() {\n    return \"BytesOutputParser\";\n  }\n  parse(text) {\n    return Promise.resolve(this.textEncoder.encode(text));\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}\n/**\n * Custom error class used to handle exceptions related to output parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class OutputParserException extends Error {\n  constructor(message, output) {\n    super(message);\n    Object.defineProperty(this, \"output\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.output = output;\n  }\n}","map":{"version":3,"names":["Runnable","BaseLLMOutputParser","parseResultWithPrompt","generations","_prompt","callbacks","parseResult","invoke","input","options","_callWithConfig","text","runType","message","content","BaseOutputParser","parse","parseWithPrompt","_type","Error","BaseTransformOutputParser","_transform","inputGenerator","chunk","transform","_transformStreamWithConfig","bind","StringOutputParser","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","value","lc_name","Promise","resolve","getFormatInstructions","BytesOutputParser","TextEncoder","textEncoder","encode","OutputParserException","output"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/schema/output_parser.js"],"sourcesContent":["import { Runnable } from \"./runnable.js\";\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport class BaseLLMOutputParser extends Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input) => this.parseResult([{ text: input }]), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input) => this.parseResult([{ message: input, text: input.content }]), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nexport class BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([{ message: chunk, text: chunk.content }]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\n/**\n * OutputParser that parses LLMResult into the top likely string.\n */\nexport class StringOutputParser extends BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"output_parser\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"StrOutputParser\";\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"output_parser\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"textEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new TextEncoder()\n        });\n    }\n    static lc_name() {\n        return \"BytesOutputParser\";\n    }\n    parse(text) {\n        return Promise.resolve(this.textEncoder.encode(text));\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n/**\n * Custom error class used to handle exceptions related to output parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class OutputParserException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,SAASD,QAAQ,CAAC;EAC9C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,qBAAqBA,CAACC,WAAW,EAAEC,OAAO,EAAEC,SAAS,EAAE;IACnD,OAAO,IAAI,CAACC,WAAW,CAACH,WAAW,EAAEE,SAAS,CAAC;EACnD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAME,MAAMA,CAACC,KAAK,EAAEC,OAAO,EAAE;IACzB,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAO,IAAI,CAACE,eAAe,CAAC,MAAOF,KAAK,IAAK,IAAI,CAACF,WAAW,CAAC,CAAC;QAAEK,IAAI,EAAEH;MAAM,CAAC,CAAC,CAAC,EAAEA,KAAK,EAAE;QAAE,GAAGC,OAAO;QAAEG,OAAO,EAAE;MAAS,CAAC,CAAC;IAC/H,CAAC,MACI;MACD,OAAO,IAAI,CAACF,eAAe,CAAC,MAAOF,KAAK,IAAK,IAAI,CAACF,WAAW,CAAC,CAAC;QAAEO,OAAO,EAAEL,KAAK;QAAEG,IAAI,EAAEH,KAAK,CAACM;MAAQ,CAAC,CAAC,CAAC,EAAEN,KAAK,EAAE;QAAE,GAAGC,OAAO;QAAEG,OAAO,EAAE;MAAS,CAAC,CAAC;IACvJ;EACJ;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMG,gBAAgB,SAASd,mBAAmB,CAAC;EACtDK,WAAWA,CAACH,WAAW,EAAEE,SAAS,EAAE;IAChC,OAAO,IAAI,CAACW,KAAK,CAACb,WAAW,CAAC,CAAC,CAAC,CAACQ,IAAI,EAAEN,SAAS,CAAC;EACrD;EACA,MAAMY,eAAeA,CAACN,IAAI,EAAEP,OAAO,EAAEC,SAAS,EAAE;IAC5C,OAAO,IAAI,CAACW,KAAK,CAACL,IAAI,EAAEN,SAAS,CAAC;EACtC;EACA;AACJ;AACA;EACIa,KAAKA,CAAA,EAAG;IACJ,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;EAC5C;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,SAASL,gBAAgB,CAAC;EAC5D,OAAOM,UAAUA,CAACC,cAAc,EAAE;IAC9B,WAAW,MAAMC,KAAK,IAAID,cAAc,EAAE;MACtC,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;QAC3B,MAAM,IAAI,CAACjB,WAAW,CAAC,CAAC;UAAEK,IAAI,EAAEY;QAAM,CAAC,CAAC,CAAC;MAC7C,CAAC,MACI;QACD,MAAM,IAAI,CAACjB,WAAW,CAAC,CAAC;UAAEO,OAAO,EAAEU,KAAK;UAAEZ,IAAI,EAAEY,KAAK,CAACT;QAAQ,CAAC,CAAC,CAAC;MACrE;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOU,SAASA,CAACF,cAAc,EAAEb,OAAO,EAAE;IACtC,OAAO,IAAI,CAACgB,0BAA0B,CAACH,cAAc,EAAE,IAAI,CAACD,UAAU,CAACK,IAAI,CAAC,IAAI,CAAC,EAAE;MAC/E,GAAGjB,OAAO;MACVG,OAAO,EAAE;IACb,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMe,kBAAkB,SAASP,yBAAyB,CAAC;EAC9DQ,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnBC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE,eAAe;IAClD,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;EACN;EACA,OAAOC,OAAOA,CAAA,EAAG;IACb,OAAO,iBAAiB;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIpB,KAAKA,CAACL,IAAI,EAAE;IACR,OAAO0B,OAAO,CAACC,OAAO,CAAC3B,IAAI,CAAC;EAChC;EACA4B,qBAAqBA,CAAA,EAAG;IACpB,OAAO,EAAE;EACb;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,SAASpB,yBAAyB,CAAC;EAC7DQ,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnBC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE,eAAe;IAClD,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACvCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,IAAIM,WAAW,CAAC;IAC3B,CAAC,CAAC;EACN;EACA,OAAOL,OAAOA,CAAA,EAAG;IACb,OAAO,mBAAmB;EAC9B;EACApB,KAAKA,CAACL,IAAI,EAAE;IACR,OAAO0B,OAAO,CAACC,OAAO,CAAC,IAAI,CAACI,WAAW,CAACC,MAAM,CAAChC,IAAI,CAAC,CAAC;EACzD;EACA4B,qBAAqBA,CAAA,EAAG;IACpB,OAAO,EAAE;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,qBAAqB,SAASzB,KAAK,CAAC;EAC7CS,WAAWA,CAACf,OAAO,EAAEgC,MAAM,EAAE;IACzB,KAAK,CAAChC,OAAO,CAAC;IACdiB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACU,MAAM,GAAGA,MAAM;EACxB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}