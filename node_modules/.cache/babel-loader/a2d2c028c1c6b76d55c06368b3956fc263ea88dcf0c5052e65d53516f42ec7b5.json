{"ast":null,"code":"import { CallbackManager } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options)) {\n      if (options.length !== length) {\n        throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n      }\n      return options;\n    }\n    return Array.from({\n      length\n    }, () => options);\n  }\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n   * @returns An array of RunOutputs\n   */\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions?.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < inputs.length; i += batchSize) {\n      const batchPromises = inputs.slice(i, i + batchSize).map((input, j) => this.invoke(input, configList[j]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n  }\n  _separateRunnableConfigFromCallOptions(options = {}) {\n    const runnableConfig = {\n      callbacks: options.callbacks,\n      tags: options.tags,\n      metadata: options.metadata\n    };\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options?.runType);\n    let output;\n    try {\n      output = await func.bind(this)(input);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    let runManager;\n    const serializedRepresentation = this.toJSON();\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (!runManager) {\n          // Start the run manager AFTER the iterator starts to preserve\n          // tracing order\n          runManager = await callbackManager_?.handleChainStart(serializedRepresentation, {\n            input: \"\"\n          }, undefined, options?.runType);\n        }\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalInput = finalInput.concat(chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    const wrappedInputGenerator = wrapInputForTracing();\n    try {\n      const outputIterator = transformer(wrappedInputGenerator, runManager, options);\n      for await (const chunk of outputIterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = finalOutput.concat(chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    });\n  }\n  _patchConfig(config = {}, callbackManager = undefined) {\n    return {\n      ...config,\n      callbacks: callbackManager\n    };\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return thing.lc_runnable;\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      for (const step of [this.first, ...this.middle]) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    let finalOutputs;\n    try {\n      for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n      }\n      finalOutputs = await this.last.batch(nextStepInputs, runManagers.map(runManager => this._patchConfig(configList[this.steps.length - 1], runManager?.getChild())), batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n    return finalOutputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let nextStepInput = input;\n    const steps = [this.first, ...this.middle, this.last];\n    // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n    // and start streaming from there\n    const streamingStartStepIndex = steps.length - [...steps].reverse().findIndex(step => typeof step.transform !== \"function\") - 1;\n    try {\n      for (const step of steps.slice(0, streamingStartStepIndex)) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    let concatSupported = true;\n    let finalOutput;\n    try {\n      let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n      for (const step of steps.slice(streamingStartStepIndex + 1)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager?.getChild()));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = finalOutput.concat(chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable)\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  static from([first, ...runnables]) {\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1])\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  async invoke(input, options\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      for (const [key, runnable] of Object.entries(this.steps)) {\n        const result = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n        output[key] = result;\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(async input => this.func(input), input, options);\n  }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(input => Promise.resolve(input), input, options);\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n  }\n  bind(kwargs) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      }\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? options.map(individualOption => ({\n      ...individualOption,\n      ...this.kwargs\n    })) : {\n      ...options,\n      ...this.kwargs\n    };\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnables = fields.runnables;\n  }\n  async invoke(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, options);\n  }\n  async batch(inputs, options, batchOptions) {\n    const keys = inputs.map(input => input.key);\n    const actualInputs = inputs.map(input => input.input);\n    const missingKey = keys.find(key => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map(key => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions?.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  async stream(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await runManager?.handleChainError(firstError);\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\nfunction _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}","map":{"version":3,"names":["CallbackManager","Serializable","IterableReadableStream","_coerceToDict","value","defaultKey","Array","isArray","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","bind","kwargs","RunnableBinding","bound","withFallbacks","fields","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","Error","from","batch","inputs","batchOptions","configList","batchSize","maxConcurrency","batchResults","i","batchPromises","slice","map","input","j","invoke","batchResult","Promise","all","push","flat","_streamIterator","stream","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","callbacks","tags","metadata","callOptions","_callWithConfig","func","callbackManager_","configure","undefined","runManager","handleChainStart","toJSON","runType","output","e","handleChainError","handleChainEnd","_transformStreamWithConfig","inputGenerator","transformer","finalInput","finalInputSupported","finalOutput","finalOutputSupported","serializedRepresentation","wrapInputForTracing","chunk","concat","wrappedInputGenerator","outputIterator","_patchConfig","config","callbackManager","pipe","coerceable","RunnableSequence","first","last","_coerceToRunnable","isRunnable","thing","lc_runnable","lc_name","middle","steps","nextStepInput","step","getChild","callbackManagers","runManagers","nextStepInputs","finalOutputs","streamingStartStepIndex","reverse","findIndex","transform","concatSupported","finalGenerator","isRunnableSequence","runnables","RunnableMap","key","entries","result","RunnableLambda","RunnablePassthrough","resolve","mergedOptions","individualOption","RouterRunnable","actualInput","keys","actualInputs","missingKey","find","optionsList","fallback","firstError","outputs"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/schema/runnable.js"],"sourcesContent":["import { CallbackManager, } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options)) {\n            if (options.length !== length) {\n                throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n            }\n            return options;\n        }\n        return Array.from({ length }, () => options);\n    }\n    /**\n     * Default implementation of batch, which calls invoke N times.\n     * Subclasses should override this method if they can batch more efficiently.\n     * @param inputs Array of inputs to each batch call.\n     * @param options Either a single call options object to apply to each batch call or an array for each call.\n     * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n     * @returns An array of RunOutputs\n     */\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < inputs.length; i += batchSize) {\n            const batchPromises = inputs\n                .slice(i, i + batchSize)\n                .map((input, j) => this.invoke(input, configList[j]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n    }\n    _separateRunnableConfigFromCallOptions(options = {}) {\n        const runnableConfig = {\n            callbacks: options.callbacks,\n            tags: options.tags,\n            metadata: options.metadata,\n        };\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options?.runType);\n        let output;\n        try {\n            output = await func.bind(this)(input);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        let runManager;\n        const serializedRepresentation = this.toJSON();\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (!runManager) {\n                    // Start the run manager AFTER the iterator starts to preserve\n                    // tracing order\n                    runManager = await callbackManager_?.handleChainStart(serializedRepresentation, { input: \"\" }, undefined, options?.runType);\n                }\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = finalInput.concat(chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        const wrappedInputGenerator = wrapInputForTracing();\n        try {\n            const outputIterator = transformer(wrappedInputGenerator, runManager, options);\n            for await (const chunk of outputIterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = finalOutput.concat(chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    _patchConfig(config = {}, callbackManager = undefined) {\n        return { ...config, callbacks: callbackManager };\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return thing.lc_runnable;\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            for (const step of [this.first, ...this.middle]) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        let finalOutputs;\n        try {\n            for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n            }\n            finalOutputs = await this.last.batch(nextStepInputs, runManagers.map((runManager) => this._patchConfig(configList[this.steps.length - 1], runManager?.getChild())), batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n        return finalOutputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        const steps = [this.first, ...this.middle, this.last];\n        // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n        // and start streaming from there\n        const streamingStartStepIndex = steps.length -\n            [...steps]\n                .reverse()\n                .findIndex((step) => typeof step.transform !== \"function\") -\n            1;\n        try {\n            for (const step of steps.slice(0, streamingStartStepIndex)) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        let concatSupported = true;\n        let finalOutput;\n        try {\n            let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            for (const step of steps.slice(streamingStartStepIndex + 1)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager?.getChild()));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = finalOutput.concat(chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    static from([first, ...runnables]) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    async invoke(input, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            for (const [key, runnable] of Object.entries(this.steps)) {\n                const result = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                output[key] = result;\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(async (input) => this.func(input), input, options);\n    }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    async invoke(input, options) {\n        return this._callWithConfig((input) => Promise.resolve(input), input, options);\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n    }\n    bind(kwargs) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, { ...options, ...this.kwargs });\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? options.map((individualOption) => ({\n                ...individualOption,\n                ...this.kwargs,\n            }))\n            : { ...options, ...this.kwargs };\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, { ...options, ...this.kwargs });\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, { ...options, ...this.kwargs });\n    }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, options);\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({ steps: runnables });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}