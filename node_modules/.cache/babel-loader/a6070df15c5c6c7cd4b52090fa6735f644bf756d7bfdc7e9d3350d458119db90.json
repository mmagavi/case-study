{"ast":null,"code":"import { getBufferString } from \"./base.js\";\nimport { BaseConversationSummaryMemory } from \"./summary.js\";\n/**\n * Class that extends BaseConversationSummaryMemory and implements\n * ConversationSummaryBufferMemoryInput. It manages the conversation\n * history in a LangChain application by maintaining a buffer of chat\n * messages and providing methods to load, save, prune, and clear the\n * memory.\n */\nexport class ConversationSummaryBufferMemory extends BaseConversationSummaryMemory {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"movingSummaryBuffer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\"\n    });\n    Object.defineProperty(this, \"maxTokenLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 2000\n    });\n    this.maxTokenLimit = fields?.maxTokenLimit ?? this.maxTokenLimit;\n  }\n  get memoryKeys() {\n    return [this.memoryKey];\n  }\n  /**\n   * Method that loads the chat messages from the memory and returns them as\n   * a string or as a list of messages, depending on the returnMessages\n   * property.\n   * @param _ InputValues object, not used in this method.\n   * @returns Promise that resolves with MemoryVariables object containing the loaded chat messages.\n   */\n  async loadMemoryVariables(_) {\n    let buffer = await this.chatHistory.getMessages();\n    if (this.movingSummaryBuffer) {\n      buffer = [new this.summaryChatMessageClass(this.movingSummaryBuffer), ...buffer];\n    }\n    let finalBuffer;\n    if (this.returnMessages) {\n      finalBuffer = buffer;\n    } else {\n      finalBuffer = getBufferString(buffer, this.humanPrefix, this.aiPrefix);\n    }\n    return {\n      [this.memoryKey]: finalBuffer\n    };\n  }\n  /**\n   * Method that saves the context of the conversation, including the input\n   * and output values, and prunes the memory if it exceeds the maximum\n   * token limit.\n   * @param inputValues InputValues object containing the input values of the conversation.\n   * @param outputValues OutputValues object containing the output values of the conversation.\n   * @returns Promise that resolves when the context is saved and the memory is pruned.\n   */\n  async saveContext(inputValues, outputValues) {\n    await super.saveContext(inputValues, outputValues);\n    await this.prune();\n  }\n  /**\n   * Method that prunes the memory if the total number of tokens in the\n   * buffer exceeds the maxTokenLimit. It removes messages from the\n   * beginning of the buffer until the total number of tokens is within the\n   * limit.\n   * @returns Promise that resolves when the memory is pruned.\n   */\n  async prune() {\n    // Prune buffer if it exceeds max token limit\n    let buffer = await this.chatHistory.getMessages();\n    if (this.movingSummaryBuffer) {\n      buffer = [new this.summaryChatMessageClass(this.movingSummaryBuffer), ...buffer];\n    }\n    let currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n    if (currBufferLength > this.maxTokenLimit) {\n      const prunedMemory = [];\n      while (currBufferLength > this.maxTokenLimit) {\n        const poppedMessage = buffer.shift();\n        if (poppedMessage) {\n          prunedMemory.push(poppedMessage);\n          currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n        }\n      }\n      this.movingSummaryBuffer = await this.predictNewSummary(prunedMemory, this.movingSummaryBuffer);\n    }\n  }\n  /**\n   * Method that clears the memory and resets the movingSummaryBuffer.\n   * @returns Promise that resolves when the memory is cleared.\n   */\n  async clear() {\n    await super.clear();\n    this.movingSummaryBuffer = \"\";\n  }\n}","map":{"version":3,"names":["getBufferString","BaseConversationSummaryMemory","ConversationSummaryBufferMemory","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","maxTokenLimit","memoryKeys","memoryKey","loadMemoryVariables","_","buffer","chatHistory","getMessages","movingSummaryBuffer","summaryChatMessageClass","finalBuffer","returnMessages","humanPrefix","aiPrefix","saveContext","inputValues","outputValues","prune","currBufferLength","llm","getNumTokens","prunedMemory","poppedMessage","shift","push","predictNewSummary","clear"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/memory/summary_buffer.js"],"sourcesContent":["import { getBufferString, } from \"./base.js\";\nimport { BaseConversationSummaryMemory, } from \"./summary.js\";\n/**\n * Class that extends BaseConversationSummaryMemory and implements\n * ConversationSummaryBufferMemoryInput. It manages the conversation\n * history in a LangChain application by maintaining a buffer of chat\n * messages and providing methods to load, save, prune, and clear the\n * memory.\n */\nexport class ConversationSummaryBufferMemory extends BaseConversationSummaryMemory {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"movingSummaryBuffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"maxTokenLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 2000\n        });\n        this.maxTokenLimit = fields?.maxTokenLimit ?? this.maxTokenLimit;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    /**\n     * Method that loads the chat messages from the memory and returns them as\n     * a string or as a list of messages, depending on the returnMessages\n     * property.\n     * @param _ InputValues object, not used in this method.\n     * @returns Promise that resolves with MemoryVariables object containing the loaded chat messages.\n     */\n    async loadMemoryVariables(_) {\n        let buffer = await this.chatHistory.getMessages();\n        if (this.movingSummaryBuffer) {\n            buffer = [\n                new this.summaryChatMessageClass(this.movingSummaryBuffer),\n                ...buffer,\n            ];\n        }\n        let finalBuffer;\n        if (this.returnMessages) {\n            finalBuffer = buffer;\n        }\n        else {\n            finalBuffer = getBufferString(buffer, this.humanPrefix, this.aiPrefix);\n        }\n        return { [this.memoryKey]: finalBuffer };\n    }\n    /**\n     * Method that saves the context of the conversation, including the input\n     * and output values, and prunes the memory if it exceeds the maximum\n     * token limit.\n     * @param inputValues InputValues object containing the input values of the conversation.\n     * @param outputValues OutputValues object containing the output values of the conversation.\n     * @returns Promise that resolves when the context is saved and the memory is pruned.\n     */\n    async saveContext(inputValues, outputValues) {\n        await super.saveContext(inputValues, outputValues);\n        await this.prune();\n    }\n    /**\n     * Method that prunes the memory if the total number of tokens in the\n     * buffer exceeds the maxTokenLimit. It removes messages from the\n     * beginning of the buffer until the total number of tokens is within the\n     * limit.\n     * @returns Promise that resolves when the memory is pruned.\n     */\n    async prune() {\n        // Prune buffer if it exceeds max token limit\n        let buffer = await this.chatHistory.getMessages();\n        if (this.movingSummaryBuffer) {\n            buffer = [\n                new this.summaryChatMessageClass(this.movingSummaryBuffer),\n                ...buffer,\n            ];\n        }\n        let currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n        if (currBufferLength > this.maxTokenLimit) {\n            const prunedMemory = [];\n            while (currBufferLength > this.maxTokenLimit) {\n                const poppedMessage = buffer.shift();\n                if (poppedMessage) {\n                    prunedMemory.push(poppedMessage);\n                    currBufferLength = await this.llm.getNumTokens(getBufferString(buffer, this.humanPrefix, this.aiPrefix));\n                }\n            }\n            this.movingSummaryBuffer = await this.predictNewSummary(prunedMemory, this.movingSummaryBuffer);\n        }\n    }\n    /**\n     * Method that clears the memory and resets the movingSummaryBuffer.\n     * @returns Promise that resolves when the memory is cleared.\n     */\n    async clear() {\n        await super.clear();\n        this.movingSummaryBuffer = \"\";\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}