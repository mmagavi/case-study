{"ast":null,"code":"import { BaseChatMemory } from \"./chat_memory.js\";\nimport { getBufferString, getInputValue, getOutputValue } from \"./base.js\";\nimport { AsyncCaller } from \"../util/async_caller.js\";\nconst MANAGED_URL = \"https://api.getmetal.io/v1/motorhead\";\n/**\n * Class for managing chat message memory using the Motorhead service. It\n * extends BaseChatMemory and includes methods for initializing the\n * memory, loading memory variables, and saving the context.\n */\nexport class MotorheadMemory extends BaseChatMemory {\n  constructor(fields) {\n    const {\n      sessionId,\n      url,\n      memoryKey,\n      timeout,\n      returnMessages,\n      inputKey,\n      outputKey,\n      chatHistory,\n      apiKey,\n      clientId,\n      ...rest\n    } = fields;\n    super({\n      returnMessages,\n      inputKey,\n      outputKey,\n      chatHistory\n    });\n    Object.defineProperty(this, \"url\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: MANAGED_URL\n    });\n    Object.defineProperty(this, \"timeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(this, \"memoryKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"history\"\n    });\n    Object.defineProperty(this, \"sessionId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // Managed Params\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"clientId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.caller = new AsyncCaller(rest);\n    this.sessionId = sessionId;\n    this.url = url ?? this.url;\n    this.memoryKey = memoryKey ?? this.memoryKey;\n    this.timeout = timeout ?? this.timeout;\n    this.apiKey = apiKey;\n    this.clientId = clientId;\n  }\n  get memoryKeys() {\n    return [this.memoryKey];\n  }\n  _getHeaders() {\n    const isManaged = this.url === MANAGED_URL;\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (isManaged && !(this.apiKey && this.clientId)) {\n      throw new Error(\"apiKey and clientId are required for managed motorhead. Visit https://getmetal.io to get your keys.\");\n    }\n    if (isManaged && this.apiKey && this.clientId) {\n      headers[\"x-metal-api-key\"] = this.apiKey;\n      headers[\"x-metal-client-id\"] = this.clientId;\n    }\n    return headers;\n  }\n  /**\n   * Method that initializes the memory by fetching the session memory from\n   * the Motorhead service. It adds the messages to the chat history and\n   * sets the context if it is not 'NONE'.\n   */\n  async init() {\n    const res = await this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n      signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n      headers: this._getHeaders()\n    });\n    const json = await res.json();\n    const data = json?.data || json; // Managed Motorhead returns { data: { messages: [], context: \"NONE\" } }\n    const {\n      messages = [],\n      context = \"NONE\"\n    } = data;\n    await Promise.all(messages.reverse().map(async message => {\n      if (message.role === \"AI\") {\n        await this.chatHistory.addAIChatMessage(message.content);\n      } else {\n        await this.chatHistory.addUserMessage(message.content);\n      }\n    }));\n    if (context && context !== \"NONE\") {\n      this.context = context;\n    }\n  }\n  /**\n   * Method that loads the memory variables. It gets the chat messages and\n   * returns them as a string or an array based on the returnMessages flag.\n   * @param _values The input values.\n   * @returns A promise that resolves with the memory variables.\n   */\n  async loadMemoryVariables(_values) {\n    const messages = await this.chatHistory.getMessages();\n    if (this.returnMessages) {\n      const result = {\n        [this.memoryKey]: messages\n      };\n      return result;\n    }\n    const result = {\n      [this.memoryKey]: getBufferString(messages)\n    };\n    return result;\n  }\n  /**\n   * Method that saves the context to the Motorhead service and the base\n   * chat memory. It sends a POST request to the Motorhead service with the\n   * input and output messages, and calls the saveContext method of the base\n   * chat memory.\n   * @param inputValues The input values.\n   * @param outputValues The output values.\n   * @returns A promise that resolves when the context is saved.\n   */\n  async saveContext(inputValues, outputValues) {\n    const input = getInputValue(inputValues, this.inputKey);\n    const output = getOutputValue(outputValues, this.outputKey);\n    await Promise.all([this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n      signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n      method: \"POST\",\n      body: JSON.stringify({\n        messages: [{\n          role: \"Human\",\n          content: `${input}`\n        }, {\n          role: \"AI\",\n          content: `${output}`\n        }]\n      }),\n      headers: this._getHeaders()\n    }), super.saveContext(inputValues, outputValues)]);\n  }\n}","map":{"version":3,"names":["BaseChatMemory","getBufferString","getInputValue","getOutputValue","AsyncCaller","MANAGED_URL","MotorheadMemory","constructor","fields","sessionId","url","memoryKey","timeout","returnMessages","inputKey","outputKey","chatHistory","apiKey","clientId","rest","Object","defineProperty","enumerable","configurable","writable","value","caller","memoryKeys","_getHeaders","isManaged","headers","Error","init","res","call","fetch","signal","AbortSignal","undefined","json","data","messages","context","Promise","all","reverse","map","message","role","addAIChatMessage","content","addUserMessage","loadMemoryVariables","_values","getMessages","result","saveContext","inputValues","outputValues","input","output","method","body","JSON","stringify"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/memory/motorhead_memory.js"],"sourcesContent":["import { BaseChatMemory } from \"./chat_memory.js\";\nimport { getBufferString, getInputValue, getOutputValue, } from \"./base.js\";\nimport { AsyncCaller } from \"../util/async_caller.js\";\nconst MANAGED_URL = \"https://api.getmetal.io/v1/motorhead\";\n/**\n * Class for managing chat message memory using the Motorhead service. It\n * extends BaseChatMemory and includes methods for initializing the\n * memory, loading memory variables, and saving the context.\n */\nexport class MotorheadMemory extends BaseChatMemory {\n    constructor(fields) {\n        const { sessionId, url, memoryKey, timeout, returnMessages, inputKey, outputKey, chatHistory, apiKey, clientId, ...rest } = fields;\n        super({ returnMessages, inputKey, outputKey, chatHistory });\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: MANAGED_URL\n        });\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3000\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"sessionId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"context\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Managed Params\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new AsyncCaller(rest);\n        this.sessionId = sessionId;\n        this.url = url ?? this.url;\n        this.memoryKey = memoryKey ?? this.memoryKey;\n        this.timeout = timeout ?? this.timeout;\n        this.apiKey = apiKey;\n        this.clientId = clientId;\n    }\n    get memoryKeys() {\n        return [this.memoryKey];\n    }\n    _getHeaders() {\n        const isManaged = this.url === MANAGED_URL;\n        const headers = {\n            \"Content-Type\": \"application/json\",\n        };\n        if (isManaged && !(this.apiKey && this.clientId)) {\n            throw new Error(\"apiKey and clientId are required for managed motorhead. Visit https://getmetal.io to get your keys.\");\n        }\n        if (isManaged && this.apiKey && this.clientId) {\n            headers[\"x-metal-api-key\"] = this.apiKey;\n            headers[\"x-metal-client-id\"] = this.clientId;\n        }\n        return headers;\n    }\n    /**\n     * Method that initializes the memory by fetching the session memory from\n     * the Motorhead service. It adds the messages to the chat history and\n     * sets the context if it is not 'NONE'.\n     */\n    async init() {\n        const res = await this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n            signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n            headers: this._getHeaders(),\n        });\n        const json = await res.json();\n        const data = json?.data || json; // Managed Motorhead returns { data: { messages: [], context: \"NONE\" } }\n        const { messages = [], context = \"NONE\" } = data;\n        await Promise.all(messages.reverse().map(async (message) => {\n            if (message.role === \"AI\") {\n                await this.chatHistory.addAIChatMessage(message.content);\n            }\n            else {\n                await this.chatHistory.addUserMessage(message.content);\n            }\n        }));\n        if (context && context !== \"NONE\") {\n            this.context = context;\n        }\n    }\n    /**\n     * Method that loads the memory variables. It gets the chat messages and\n     * returns them as a string or an array based on the returnMessages flag.\n     * @param _values The input values.\n     * @returns A promise that resolves with the memory variables.\n     */\n    async loadMemoryVariables(_values) {\n        const messages = await this.chatHistory.getMessages();\n        if (this.returnMessages) {\n            const result = {\n                [this.memoryKey]: messages,\n            };\n            return result;\n        }\n        const result = {\n            [this.memoryKey]: getBufferString(messages),\n        };\n        return result;\n    }\n    /**\n     * Method that saves the context to the Motorhead service and the base\n     * chat memory. It sends a POST request to the Motorhead service with the\n     * input and output messages, and calls the saveContext method of the base\n     * chat memory.\n     * @param inputValues The input values.\n     * @param outputValues The output values.\n     * @returns A promise that resolves when the context is saved.\n     */\n    async saveContext(inputValues, outputValues) {\n        const input = getInputValue(inputValues, this.inputKey);\n        const output = getOutputValue(outputValues, this.outputKey);\n        await Promise.all([\n            this.caller.call(fetch, `${this.url}/sessions/${this.sessionId}/memory`, {\n                signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,\n                method: \"POST\",\n                body: JSON.stringify({\n                    messages: [\n                        { role: \"Human\", content: `${input}` },\n                        { role: \"AI\", content: `${output}` },\n                    ],\n                }),\n                headers: this._getHeaders(),\n            }),\n            super.saveContext(inputValues, outputValues),\n        ]);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}