{"ast":null,"code":"import { BaseChatMemory } from \"./chat_memory.js\";\n/**\n * Class that manages and manipulates previous chat messages. It extends\n * from the BaseChatMemory class and implements the CombinedMemoryInput\n * interface.\n */\nexport class CombinedMemory extends BaseChatMemory {\n  constructor(fields) {\n    super({\n      chatHistory: fields?.chatHistory,\n      returnMessages: fields?.returnMessages ?? false,\n      inputKey: fields?.inputKey,\n      outputKey: fields?.outputKey\n    });\n    Object.defineProperty(this, \"humanPrefix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"Human\"\n    });\n    Object.defineProperty(this, \"aiPrefix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"AI\"\n    });\n    Object.defineProperty(this, \"memoryKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"history\"\n    });\n    Object.defineProperty(this, \"memories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this.memories = fields?.memories ?? this.memories;\n    this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n    this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n    this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n    this.checkRepeatedMemoryVariable();\n    this.checkInputKey();\n  }\n  /**\n   * Checks for repeated memory variables across all memory objects. Throws\n   * an error if any are found.\n   */\n  checkRepeatedMemoryVariable() {\n    const allVariables = [];\n    for (const memory of this.memories) {\n      const overlap = allVariables.filter(x => memory.memoryKeys.includes(x));\n      if (overlap.length > 0) {\n        throw new Error(`The same variables ${[...overlap]} are found in multiple memory objects, which is not allowed by CombinedMemory.`);\n      }\n      allVariables.push(...memory.memoryKeys);\n    }\n  }\n  /**\n   * Checks if input keys are set for all memory objects. Logs a warning if\n   * any are missing.\n   */\n  checkInputKey() {\n    for (const memory of this.memories) {\n      if (memory.chatHistory !== undefined && memory.inputKey === undefined) {\n        console.warn(`When using CombinedMemory, input keys should be set so the input is known. Was not set on ${memory}.`);\n      }\n    }\n  }\n  /**\n   * Loads memory variables from all memory objects.\n   * @param inputValues Input values to load memory variables from.\n   * @returns Promise that resolves with an object containing the loaded memory variables.\n   */\n  async loadMemoryVariables(inputValues) {\n    let memoryData = {};\n    for (const memory of this.memories) {\n      const data = await memory.loadMemoryVariables(inputValues);\n      memoryData = {\n        ...memoryData,\n        ...data\n      };\n    }\n    return memoryData;\n  }\n  /**\n   * Saves the context to all memory objects.\n   * @param inputValues Input values to save.\n   * @param outputValues Output values to save.\n   * @returns Promise that resolves when the context has been saved to all memory objects.\n   */\n  async saveContext(inputValues, outputValues) {\n    for (const memory of this.memories) {\n      await memory.saveContext(inputValues, outputValues);\n    }\n  }\n  /**\n   * Clears all memory objects.\n   * @returns Promise that resolves when all memory objects have been cleared.\n   */\n  async clear() {\n    for (const memory of this.memories) {\n      if (typeof memory.clear === \"function\") {\n        await memory.clear();\n      }\n    }\n  }\n  get memoryKeys() {\n    const memoryKeys = [];\n    for (const memory of this.memories) {\n      memoryKeys.push(...memory.memoryKeys);\n    }\n    return memoryKeys;\n  }\n}","map":{"version":3,"names":["BaseChatMemory","CombinedMemory","constructor","fields","chatHistory","returnMessages","inputKey","outputKey","Object","defineProperty","enumerable","configurable","writable","value","memories","humanPrefix","aiPrefix","memoryKey","checkRepeatedMemoryVariable","checkInputKey","allVariables","memory","overlap","filter","x","memoryKeys","includes","length","Error","push","undefined","console","warn","loadMemoryVariables","inputValues","memoryData","data","saveContext","outputValues","clear"],"sources":["/Users/mayamagavi/instalily/case-study/node_modules/langchain/dist/memory/combined_memory.js"],"sourcesContent":["import { BaseChatMemory } from \"./chat_memory.js\";\n/**\n * Class that manages and manipulates previous chat messages. It extends\n * from the BaseChatMemory class and implements the CombinedMemoryInput\n * interface.\n */\nexport class CombinedMemory extends BaseChatMemory {\n    constructor(fields) {\n        super({\n            chatHistory: fields?.chatHistory,\n            returnMessages: fields?.returnMessages ?? false,\n            inputKey: fields?.inputKey,\n            outputKey: fields?.outputKey,\n        });\n        Object.defineProperty(this, \"humanPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Human\"\n        });\n        Object.defineProperty(this, \"aiPrefix\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AI\"\n        });\n        Object.defineProperty(this, \"memoryKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"history\"\n        });\n        Object.defineProperty(this, \"memories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.memories = fields?.memories ?? this.memories;\n        this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n        this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n        this.checkRepeatedMemoryVariable();\n        this.checkInputKey();\n    }\n    /**\n     * Checks for repeated memory variables across all memory objects. Throws\n     * an error if any are found.\n     */\n    checkRepeatedMemoryVariable() {\n        const allVariables = [];\n        for (const memory of this.memories) {\n            const overlap = allVariables.filter((x) => memory.memoryKeys.includes(x));\n            if (overlap.length > 0) {\n                throw new Error(`The same variables ${[\n                    ...overlap,\n                ]} are found in multiple memory objects, which is not allowed by CombinedMemory.`);\n            }\n            allVariables.push(...memory.memoryKeys);\n        }\n    }\n    /**\n     * Checks if input keys are set for all memory objects. Logs a warning if\n     * any are missing.\n     */\n    checkInputKey() {\n        for (const memory of this.memories) {\n            if (memory.chatHistory !== undefined &&\n                memory.inputKey === undefined) {\n                console.warn(`When using CombinedMemory, input keys should be set so the input is known. Was not set on ${memory}.`);\n            }\n        }\n    }\n    /**\n     * Loads memory variables from all memory objects.\n     * @param inputValues Input values to load memory variables from.\n     * @returns Promise that resolves with an object containing the loaded memory variables.\n     */\n    async loadMemoryVariables(inputValues) {\n        let memoryData = {};\n        for (const memory of this.memories) {\n            const data = await memory.loadMemoryVariables(inputValues);\n            memoryData = {\n                ...memoryData,\n                ...data,\n            };\n        }\n        return memoryData;\n    }\n    /**\n     * Saves the context to all memory objects.\n     * @param inputValues Input values to save.\n     * @param outputValues Output values to save.\n     * @returns Promise that resolves when the context has been saved to all memory objects.\n     */\n    async saveContext(inputValues, outputValues) {\n        for (const memory of this.memories) {\n            await memory.saveContext(inputValues, outputValues);\n        }\n    }\n    /**\n     * Clears all memory objects.\n     * @returns Promise that resolves when all memory objects have been cleared.\n     */\n    async clear() {\n        for (const memory of this.memories) {\n            if (typeof memory.clear === \"function\") {\n                await memory.clear();\n            }\n        }\n    }\n    get memoryKeys() {\n        const memoryKeys = [];\n        for (const memory of this.memories) {\n            memoryKeys.push(...memory.memoryKeys);\n        }\n        return memoryKeys;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}